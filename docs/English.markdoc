
`jVue`
======

Back-End SFC Compiler
---------------------	
	
	Purpose
	-------	
		
		To compile `.vue` file to ES 6 module.
		
	Download
	--------	
		
		```	.sh
			npm install j-vue
		
	Load
	----	
		
		```	.js
			const jVue = require('j-vue');
		
	API
	---	
		
		`new jVue.SFC(vue)`
		-------------------	
			
			The parameter `vue` is the original `Buffer` (recommended) or a `string` of `.vue` file.
			
			In order to avoid unexpected parsing ambiguity, errors will be reported as strictly as possible.
			
		`sfc.export('default'[, from = '?j-vue'])`
		-------------------------------------------	
			
			To generate the component's default export content string according to the content in `script` block or its `src' attribute. (For the generated `JavaScript` code is padded line wrapping and indentation as the original file, so source map is not provided.)
			
			Note: If there is a `lang` attribute which value is other than `js` / `jsx` / `ts` / `tsx` (or semantic similar), then the user must transpile (its `inner` property value) and set to its `innerJS` property.
			
			When there is no `script` block, the second parameter `from' is used as the `import` path to introduce the `template' information of the file.
			
		`sfc.export('var'  [, from = 'j-vue'])`
		`sfc.export('const'[, from = 'j-vue'])`
		`sfc.export('let'  [, from = 'j-vue'])`
		---------------------------------------	
			
			When the second parameter `from` is string or default, it will be used as the module id to introduce the jVue front-end runtime dependency library.
			
			Then here is going to generate the component's `dynamicScope` (or `staticScope`)、`template`、`render`、`staticRenderFns` self using information export string, according to the contents in `template` and `style` blocks or their `src' attribute.
			The exports of `j-vue` will be exported too, to make them simply to use.
			Module content is similar to this:
			
			```	.js
				import { Scope, Template, Render, StaticRenderFns } from 'j-vue';
				export var dynamicScope = Scope();
				export var template = Template('<div />', dynamicScope);
				export var render = Render('_vm,_c("div")', dynamicScope);
				export var staticRenderFns = StaticRenderFns([], dynamicScope);
				export * from 'j-vue';
			
			When use `const` or `let`, the parameter of `Render` and `StaticRenderFns` (the compiled template) will also be compressed as ES 6.
			
			当第二个参数 `from` 为 `null` 时，表示 `template` 和 `style` 块并不需要防冲突处理（一般用于会使用 Shadow DOM 的场景）。这时的导出内容是：
			
			```	.js
				export var styles = [];
				export var template = '<div />';
				export var render = function () { var _vm = this, _c = _vm._self_c; return _c('div'); };
				export var staticRenderFns = [];
			
			Note: If there is a `lang` attribute which value is other than `html` (or semantic similar) in the `template` block, or any `style` block has a `lang` attribute which value is other than `css` (or semantic similar), then the user must transpile (its `inner` property value) and set to its `innerHTML` / `innerCSS` property.
	
Front-End Runtime Dependency
----------------------------	
	
	Purpose
	-------	
		
		When use `@ltd/j-dev`#1# to build a front end project including `.vue` file#2#, the final front end runtime code generated, need to use this module to finish the final step.
		(The reason why the building can't be completed while front-end compiling, is due to the global unique identifier generator must execute in the final running scenario. Only in this way, we can ensure the selector names for scoped style and so on will never conflict.)
		
		#1#	A package published on `NPM`. It's a tool for automatic project building.
		#2#	The single-file component of `Vue`. It's convenient for developing, but need compiling.
		
	Download
	--------	
		
		>> https://GitHub.com/LongTengDao/j-vue/tree/master/dist/ <<
		
	Load
	----	
		
		Global Mode
		-----------	
			```	.html
				<script src="j-vue.js"></script>
				<script>
					jVue;
				</script>
			
		AMD Mode (Take `RequireJS` for example)
		--------	
			
			Global Load
			-----------	
				```	.html
					<script src="require.js"></script>
					<script>
						require(['j-vue'], function (jVue) {
							jVue;
						});
					</script>
				
			Load in Module
			--------------	
				```	.js
					define(['j-vue'], function (jVue) {
						jVue;
					});
		
	API
	---	
		`jVue.Identifier()`
		-------------------	
			
			Return a global unique identifier#3#.
			
		#3#	"identifier" is a `string`; identifier generated each time, is global unique in `jVue`.
			It's leaded by a lowercase letter, and followed with lowercase letters or digits (under the rule for `.key` mode bare key name accessing to object property in `JavaScript (ECMAScript 5+)`).
			The aim is to be as short as possible, while being based on the premise that it can be used for legal `class` selector or any other purpose, with high cache index performance (avoid to become "dict mode" or require case conversion).
			(Because of I can't imagine the application scenario that need to avoid JS syntax reserved words, so I didn't exclude them. If you have reason, tell me via issues, adding it is very easy.
			However, in order to be able to be a keyframe name, etc., several CSS syntax reserved words `inherit`, `initial`, `unset`, `default`, `none`, `auto`, `span`, `contents` are avoided.
			`notranslate` has side effects when used as `class`, so it will also be skipped.
			In addition, because the predefined counter style name list that needs to be avoided is too long and different environments may have different implementations, it is suggested to add `-` or `_` as protective suffix after it.)
			
		`jVue.Scope([keys])`
		--------------------	
			
			If the parameter `keys` not exists, it will return an identifier generator `scope` in `function` type. When use that, the only parameter `key` is a `string`, the value returned is a global unique identifier#3# (for same identifier generator, pass same `key` in, you will get same value).
			Alternatively, you can pass arguments allowed by `:class` directly into this function (`string`, `object`, or `Array`), which will convert the aliases one by one.
			
			If the parameter `keys` exists, it will return an `object` `scope`. The `keys` should be a `string`, using charactor(s) which `/[a-z][a-z0-9]*(?:_[a-z0-9]+)*/i` won't match to split each `key` inner. Global unique identifiers#3# will be generated for each `key`, and be cached in the `object` returned (the key name is the corresponding `key`).
			In addition to higher runtime performance, this allows you to specify what needs to be captured by the regular.
			
			This function allows you to use another `scope` as `this`. In this case, the new `scope` returned will "extend" `this`.
			`this` can also be an `Array` of `scope`. In this case, the new `scope` returned will "extend" an `scope` which mixed all these `scope` in.
			
		<RE>	`/__[a-z][a-z0-9]*(?:_[a-z0-9]+)*__/ig`
			
		`jVue.Style(css[, scope])`
		--------------------------	
			
			Create a `<style>`, append to the `<head>` node, and return that `<style>`.
			
			The parameter `css` is a `string`, as the content of the `<style>` created.
			
			If the second parameter `scope` exists, all parts matching <RE> in parameter `css` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
			
		`jVue.remove(style)`
		--------------------	
			
			The parameter `style` is a `<style>`, it will be removed from the `<head>` node.
			
			The returned value of the function is itself, so as to chaining call.
			
		`jVue.Template(html, scope)`
		----------------------------	
			
			The parameter `html` is a `string`, all parts matched <RE> in `html` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`, then return.
			
		`jVue.Render(code[, scope])`
		----------------------------	
			
			The parameter `code` is a `string`, and the value returned is <Fn>.
			
			If the second parameter `scope` exists, all parts matched <RE> in `code` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
			
		<Fn>	`Function( code.replace( /^([^,]*),([^(]*)\(([^]*)\)$/, (_vm, _c, args) => ` "use strict"; var ${_vm && _vm+' = this, '}${_c} = this._self._c; return ${_c}(${args}); ` ) )`
			
		`jVue.StaticRenderFns(codes[, scope])`
		--------------------------------------	
			
			The parameter `codes` is an `Array` of `string`, and the value returned is an `Array` of `function` (using <Fn> to generate each one).
			
			If the second parameter `scope` exists, then all parts matched <RE> in each `string`, will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
			
		`jVue.STYLE`
		------------	
			
			Because `Vue` disables the inclusion of `<style>` elements in component templates, this is inconvenient in the case that we have already handled the component-scoped `CSS` on our own.
			`jVue` provides a simple component:
			
			```	.js
				({
					functional: true,
					render: function render (createElement, context) {
						return createElement('style', context.data, context.children);
					}
				})
			
			You can put it into the `components` of your component, or register it global, then do like this:
			
			```	.html
				<STYLE v-text="`
					.scoped-preview-area-selector { background-color:${ theme_color }; }
				`" />
				<STYLE v-text="computedPropertyCSS" />
			
			Or do this (note that the content between tags will be treated as `HTML` fragment by `Vue`, so this is more suitable for simple cases without `<` and such things, or properly handle `HTML` entries escaping):
			
			```	.html
				<STYLE>
					.scoped-preview-area-selector { background-color:{{ theme_color }}; }
				</STYLE>
			
			Note: The reactivity of `Vue` is asynchronous naturally, so if you need high reactivity, then you must do like this (note that the reference of functional component is `<style>` element directly, not a `Vue` instance, so don't fetch that through `.$el`):
			
			```	.js
				({
					template: `
						<div @scroll="onScroll">
							<STYLE ref="sheet" />
						</div>`,
					methods: {
						onScroll () {
							this.$refs.sheet.textContent = `
								.scoped-selector { top:${ this.$el.scrollTop }; }
							`;
						}
					}
				})
