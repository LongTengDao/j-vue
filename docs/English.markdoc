
`jVue`
======

purpose
-------	
	
	When use `@ltd/j-dev`#1# to build a front end project including `.vue` file#2#, the final front end runtime code generated, need to use this module to finish the final step.
	(The reason why the building can't be completed on server side, is due to the global unique identifier generator must execute in the final running scenario. Only in this way, we can ensure the selector names for scoped style and so on will never conflict.)
	
	#1#	A package published on `NPM`. It's a tool for automatic project building.
	#2#	The single file component of `Vue`. It's convenient for developing, but need compiling.
	
Download
--------	
	
	>> https://GitHub.com/LongTengDao/j-vue/tree/master/dist/ <<
	
Load
----	
	
	Global Mode
	-----------	
		```	.html
			<script src="j-vue.js"></script>
			<script>
				jVue;
			</script>
		
	AMD Mode (Take `RequireJS` for example)
	--------	
		
		Global Load
		-----------	
			```	.html
				<script src="require.js"></script>
				<script>
					require(['j-vue'], function (jVue) {
						jVue;
					});
				</script>
			
		Load in Module
		--------------	
			```	.js
				define(['j-vue'], function (jVue) {
					jVue;
				});
	
API
---	
	`jVue.Identifier()`
	-------------------	
		
		Return a global unique identifier#3#.
		
	#3#	"identifier" is a `string`; identifier generated each time, is global unique in `jVue`.
		It's leaded by a lowercase letter, and followed with lowercase letters or digits (same as the rule for `.key` mode bare key name accessing to object property in `JavaScript (ECMAScript 5+)`).
		The aim is to be as short as possible, while being based on the premise that it can be used for legal `class` selector or any other purpose, with high cache index performance (avoid to become "dict mode").
		(Because of I can't imagine the application scenario that need to avoid syntax reserved words, so I didn't exclude them. If you have reason, tell me via issues, adding it is very easy.)
	
	`jVue.Scope([keys])`
	--------------------	
		
		If the parameter `keys` not exists, it will return an identifier generator in `function` type. When use that, the only parameter `key` is a `string`, the value returned is a global unique identifier#3# (for same identifier generator, pass same `key` in, you will get same value).
		
		If the parameter `keys` exists, it will return an `object`. The `keys` should be a `string`, using `|` split each `key` inner. Global unique identifiers#3# will be generated for each `key`, and be cached in the `object` returned (the key name is the corresponding `key`).
		In addition to higher runtime performance, this allows you to specify what needs to be captured by the regular.
		
		This function allows you to use another `object` `scope` as `this`. In this case, the new `scope` returned will "extend" `this`.
		
		`this` can also be an `Array` of `object` `scope`. In this case, the new `scope` returned will "extend" an `object` `scope` which mixed all these `object` `scope` in.
		
	<RE>	`/__[a-z][a-z0-9]*(?:_[a-z0-9]+)*__/ig`
		
	`jVue.Style(css[, scope])`
	--------------------------	
		
		Create a `<style>`, append to the `<head>` node, and return that `<style>`.
		
		The parameter `css` is a `string`, as the content of the `<style>` created.
		
		If the second parameter `scope` exists, all parts matching <RE> in parameter `css` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
		
	`jVue.remove(style)`
	--------------------	
		
		The parameter `style` is a `<style>`, it will be removed from the `<head>` node.
		
		The returned value of the function is itself, so as to chaining call.
		
	`jVue.Template(html, scope)`
	----------------------------	
		
		The parameter `html` is a `string`, all parts matched <RE> in `html` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`, then return.
		
	`jVue.Render(code[, scope])`
	----------------------------	
		
		The parameter `code` is a `string`, and the value returned is `Function('with(this){return '+code+'}')`.
		
		If the second parameter `scope` exists, all parts matched <RE> in `code` will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
		
	`jVue.StaticRenderFns(codes[, scope])`
	--------------------------------------	
		
		The parameter `codes` is an `Array` of `string`, and the value returned is an `Array` of `function` (using `Function('with(this){return '+code+'}')` to generate each one).
		
		If the second parameter `scope` exists, then all parts matched <RE> in each `string`, will be replaced to the `key` (the matched part after `.slice(2, -2)`) mapped value in the `scope`.
		
	`jVue.STYLE`
	------------	
		
		Because `Vue` disables the inclusion of `<style>` elements in component templates, this is inconvenient in the case that we have already handled the component-scoped `CSS` on our own.
		`jVue` provides a simple component:
		
		```	.js
			({
				functional: true,
				render: function render (createElement, context) {
					return createElement('style', context.data, context.children);
				}
			})
		
		You can put it into the `components` of your component, or register it global, then do like this:
		
		```	.html
			<STYLE v-text="`
				.scoped-preview-area-selector { background-color:${ theme_color }; }
			`" />
			<STYLE v-text="computedPropertyCSS" />
		
		Or do this (note that the content between tags will be treated as `HTML` fragment by `Vue`, so this is more suitable for simple cases without `<` and such things, or properly handle `HTML` entries escaping):
		
		```	.html
			<STYLE>
				.scoped-preview-area-selector { background-color:{{ theme_color }}; }
			</STYLE>
		
		Note: The reactivity of `Vue` is asynchronous naturally, so if you need high reactivity, then you must do like this (note that the reference of functional component is `<style>` element directly, not a `Vue` instance, so don't fetch that through `.$el`):
		
		```	.js
			({
				template: `
					<div @scroll="onScroll">
						<STYLE ref="sheet" />
					</div>`,
				methods: {
					onScroll () {
						this.$refs.sheet.textContent = `
							.scoped-selector { top:${ this.$el.scrollTop }; }
						`;
					}
				}
			})
