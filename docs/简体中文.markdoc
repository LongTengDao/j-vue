
`jVue`
======

单文件组件后端编译器
--------------------	
	
	用途
	----	
		
		将 `.vue` 单文件组件编译成 ES 6 模块。
		
	下载
	----	
		
		```	.sh
			npm install j-vue
		
	加载
	----	
		
		```	.js
			const jVue = require('j-vue');
		
	API
	---	
		
		`new jVue.SFC(vue)`
		-------------------	
			
			参数 `vue` 是 `.vue` 文件的原始 `Buffer`（建议），或 `string`。
			
			为避免意外的解析分歧，会尽可能地严格报错。
			
		`sfc.export('default'[, from = '?j-vue'])`
		-------------------------------------------	
			
			根据 `script` 块中的内容，或其 `src` 属性，生成组件的对外默认导出内容字符串。（生成的 `JavaScript` 代码会根据原始文件换行和缩进进行位移，所以不提供源映射内容。）
			
			注意：如果存在非 `js` / `jsx` / `ts` / `tsx`（或语义近似值）的 `lang` 属性，那么用户必须自行（根据其 `inner` 属性中的内容）转码，并赋值给其 `innerJS` 属性。
			
			当不存在 `script` 块时，会用到第二个参数 `from` 作为 `import` 的路径，来引入该文件的 `template` 信息。
			
		`sfc.export('var'  [, from = 'j-vue'])`
		`sfc.export('const'[, from = 'j-vue'])`
		`sfc.export('let'  [, from = 'j-vue'])`
		---------------------------------------	
			
			根据 `template` 块和 `style` 块中的内容，或其 `src` 属性，生成组件自身的 `dynamicScope`（或 `staticScope`）、`template`、`render`、`staticRenderFns` 信息导出模块字符串。模块内容类似这样：
			
			```	.js
				import * as jVue from 'j-vue';
				export var dynamicScope = jVue.Scope();
				export var template = jVue.Template('<div />', dynamicScope);
				export var render = jVue.Render('_vm,_c("div")', dynamicScope);
				export var staticRenderFns = jVue.StaticRenderFns([], dynamicScope);
				export * from 'j-vue';
			
			当选择 `const` 或 `let` 时，`Render` 和 `StaticRenderFns` 的参数（编译后的模板）也会作为 ES 6 代码进行压缩。
			
			注意：如果 `template` 块存在非 `html`（或语义近似值）的 `lang` 属性，或任何 `style` 块存在非 `css`（或语义近似值）的 `lang` 属性，那么用户必须自行（根据其 `inner` 属性中的内容）转码，并赋值给其 `innerHTML` / `innerCSS` 属性。
			
			第二个参数 `from`，是用于引入 jVue 前端运行时依赖库的模块名。
			
			`j-vue` 中的内容也会一并导出，以便于使用。
	
前端运行时依赖
--------------	
	
	用途
	----	
		
		当使用 `@ltd/j-dev`#1# 构建包含 `.vue` 文件##2##的前端项目时，最终生成的前端运行时代码，需要用到此模块来完成最终步骤。
		（之所以无法在后端编译时进行完全构建，是因为全局唯一的发号器，必须在最终运行场景执行。只有这样，才能保证各组件的局部样式选择器名等绝对不会冲突。）
		
		#1#	发布在 `NPM` 上的包。是一个自动化构建项目的工具。
		#2#	`Vue` 的单文件组件。便于开发，但需要编译后才能运行。
		
	下载
	----	
		
		>> https://GitHub.com/LongTengDao/j-vue/tree/master/dist/ <<
		
	加载
	----	
		
		全局模式
		--------	
			```	.html
				<script src="j-vue.js"></script>
				<script>
					jVue;
				</script>
			
		AMD 模式（以 `RequireJS` 实现为例）
		--------	
			
			全局加载
			--------	
				```	.html
					<script src="require.js"></script>
					<script>
						require(['j-vue'], function (jVue) {
							jVue;
						});
					</script>
				
			模块内加载
			----------	
				```	.js
					define(['j-vue'], function (jVue) {
						jVue;
					});
		
	API
	---	
		`jVue.Identifier()`
		-------------------	
			
			返回一个全局唯一的号##3##。
			
		#3#	“号”是一个 `string`；每次发的号，在 `jVue` 内部全局唯一。
			它由小写字母打头，后面的部分是小写字母或数字（符合 `JavaScript (ECMAScript 5+)` 中，`.key` 式访问对象属性时的裸键名规则）。
			目的是能够用作合法的 `class` 选择器等任何用途、高缓存索引性能（避免退化成“字典模式”或需要 case 转化的工序）的前提下，长度尽可能短。
			（由于想不出需要避讳 JS 语法保留字的应用场景，所以没有在发号时排除它们。如果你有，请提 issue，加上它是很容易的。
			但是为了能够作为 keyframes name 等，会避开 `inherit`、`initial`、`unset`、`default`、`none`、`auto`、`span`、`contents` 几个 CSS 语法保留字。
			另外，由于需要回避的预定义 counter style name 清单过长，而且不同环境可能有不同的实现，建议自行在其后加上 `-` 或 `_` 作为安全后缀。）
			
		`jVue.Scope([keys])`
		--------------------	
			
			当缺省参数 `keys` 时，返回一个 `function` 发号器 `scope`。使用它时，唯一的参数 `key` 是一个 `string`，返回的值是一个全局唯一的号##3##（对同一个发号器，传入同一个 `key`，会得到同一个值）。
			另外，你还可以将 `:class` 允许的参数直接传入这个函数（`string`、`object` 或 `Array`），它将逐一转化其中的别名。
			
			如果参数 `keys` 存在，返回一个 `object` `scope`。`keys` 应当是一个 `string`，内部的每个 `key` 用 `/[a-z][a-z0-9]*(?:_[a-z0-9]+)*/i` 不匹配的字符分隔。将会为这些 `key` 逐一生成全局唯一的号##3##，并缓存在返回的 `object` 中（键名是对应的 `key`）。
			除了运行时性能更高，这还允许你精确控制需要被 <正则> 捕获的内容。
			
			该函数允许使用另一个 `scope` 作为 `this`。这种情况下，所返回的新 `scope` 将“继承”自 `this`。
			`this` 也可以是由 `scope` 组成的 `Array`。这种情况下，所返回的新 `scope` 将“继承”自这些 `scope` 混合之后的 `scope`。
			
		<正则>	`/__[a-z][a-z0-9]*(?:_[a-z0-9]+)*__/ig`
			
		`jVue.Style(css[, scope])`
		--------------------------	
			
			创建一个 `<style>`，追加到 `<head>` 节点中，并返回这个 `<style>`。
			
			参数 `css` 是一个 `string`，作为创建的 `<style>` 的内容。
			
			如果存在第二个参数 `scope`，那么参数 `css` 中所有匹配 <正则> 的部分，都会被替换成 `scope` 中的该 `key`（匹配部分 `.slice(2, -2)` 后的值）映射的值。
			
		`jVue.remove(style)`
		--------------------	
			
			参数 `style` 是一个 `<style>`，它将被从 `<head>` 节点中移除。
			
			函数的返回值是该函数本身，以便于链式调用。
			
		`jVue.Template(html, scope)`
		----------------------------	
			
			参数 `html` 是一个 `string`，`html` 中所有匹配 <正则> 的部分，都会被替换成 `scope` 中该 `key`（匹配部分 `.slice(2, -2)` 后的值）所映射的值，然后返回。
			
		`jVue.Render(code[, scope])`
		----------------------------	
			
			参数 `code` 是一个 `string`，返回 <函数>。
			
			如果存在第二个参数 `scope`，那么 `code` 中所有匹配 <正则> 的部分，都会被替换成 `scope` 中该 `key`（匹配部分 `.slice(2, -2)` 后的值）所映射的值。
			
		<函数>	`Function( code.replace( /^([^,]*),([^(]*)\(([^]*)\)$/, (_vm, _c, args) => ` "use strict"; var ${_vm && _vm+' = this, '}${_c} = this._self._c; return ${_c}(${args}); ` ) )`
			
		`jVue.StaticRenderFns(codes[, scope])`
		--------------------------------------	
			
			参数 `codes` 是一个 `string` `Array`，返回 `function` `Array`（逐一用 <函数> 生成）。
			
			如果存在第二个参数 `scope`，那么生成时用的每个 `string` 中所有匹配 <正则> 的部分，都会被替换成 `scope` 中该 `key`（匹配部分 `.slice(2, -2)` 后的值）所映射的值。
			
		`jVue.STYLE`
		------------	
			
			由于 `Vue` 禁止组件模板中包含 `<style>` 元素，这在我们已经自行搞定了组件作用域的 `CSS` 的情况下，反而带来了不便。
			`jVue` 提供了一个简单的组件：
			
			```	.js
				({
					functional: true,
					render: function render (createElement, context) {
						return createElement('style', context.data, context.children);
					}
				})
			
			你可以在你的组件的 `components` 中放入它，或全局注册它，然后这样使用：
			
			```	.html
				<STYLE v-text="`
					.scoped-preview-area-selector { background-color:${ theme_color }; }
				`" />
				<STYLE v-text="computedPropertyCSS" />
			
			或这样使用（注意标签之间的内容会被 `Vue` 理解为 `HTML` 片段，比较适合没有 `<` 等的简单情况，或妥善处理 `HTML` 实体转义）：
			
			```	.html
				<STYLE>
					.scoped-preview-area-selector { background-color:{{ theme_color }}; }
				</STYLE>
			
			注意：`Vue` 的响应式天然是异步的，如果你需要高响应性，那么你必须类似这样做（注意纯函数组件引用直接就是 `<style>` 元素，而不是 `Vue` 示例，不要通过 `.$el` 来获取）：
			
			```	.js
				({
					template: `
						<div @scroll="onScroll">
							<STYLE ref="sheet" />
						</div>`,
					methods: {
						onScroll () {
							this.$refs.sheet.textContent = `
								.scoped-selector { top:${ this.$el.scrollTop }; }
							`;
						}
					}
				})
